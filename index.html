<!DOCTYPE html>
<html>
<head>
  <title>Patient Data Collection App</title>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <style>
    body {
      padding: 20px;
    }

    .container {
      max-width: 100%;
      margin: 0 auto;
    }

    .section {
      margin-bottom: 20px;
    }

    #handwritingCanvas {
      border: 1px solid #000;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center">Patient Data Collection App</h1>
    <div class="section">
      <h2>Voice Recording</h2>
      <div class="text-center">
        <button type="button" class="btn btn-primary" id="startRecording">Start</button>
        <button type="button" class="btn btn-danger" id="stopRecording" disabled>Stop</button>
      </div>
      <div id="recordingVisual" class="text-center mt-2"></div>
    </div>
    <div class="section">
      <h2>Handwriting Spiral</h2>
      <div class="text-center">
        <canvas id="handwritingCanvas"></canvas>
        <button type="button" class="btn btn-primary mt-2" id="clearCanvas">Clear</button>
      </div>
    </div>
    <div class="section">
      <h2>Accelerometer Data</h2>
      <table id="accelerometerTable" class="table">
        <thead>
          <tr>
            <th scope="col">Timestamp</th>
            <th scope="col">Acceleration X</th>
            <th scope="col">Acceleration Y</th>
            <th scope="col">Acceleration Z</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
    <div class="text-center">
      <button type="button" class="btn btn-success" id="submitData">Submit Data</button>
    </div>
  </div>

  <script>
    // Voice Recording
    let recorder;
    let chunks = [];
    let recordingVisualInterval;

    function startRecording() {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(function(stream) {
          recorder = new MediaRecorder(stream);
          recorder.ondataavailable = function(e) {
            chunks.push(e.data);
          };
          recorder.start();
          document.getElementById('startRecording').disabled = true;
          document.getElementById('stopRecording').disabled = false;
          document.getElementById('recordingVisual').textContent = 'Recording in progress...';
          recordingVisualInterval = setInterval(function() {
            document.getElementById('recordingVisual').textContent += '.';
          }, 1000);
        })
        .catch(function(err) {
          console.log('Error: ' + err);
        });
    }

    function stopRecording() {
      recorder.stop();
      document.getElementById('startRecording').disabled = false;
      document.getElementById('stopRecording').disabled = true;
      clearInterval(recordingVisualInterval);
      document.getElementById('recordingVisual').textContent = '';
    }

    document.getElementById('startRecording').addEventListener('click', startRecording);
    document.getElementById('stopRecording').addEventListener('click', stopRecording);

    // Handwriting Spiral
    const canvas = document.getElementById('handwritingCanvas');
    const ctx = canvas.getContext('2d');
    let isDrawing = false;

    function startDrawing(e) {
      isDrawing = true;
      ctx.beginPath();
      ctx.moveTo(getX(e), getY(e));
    }

    function draw(e) {
      if (!isDrawing) return;
      ctx.lineTo(getX(e), getY(e));
      ctx.stroke();
    }

    function stopDrawing() {
      isDrawing = false;
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function getX(e) {
      if (e.type === 'touchmove' || e.type === 'touchend') {
        return e.touches[0].clientX - canvas.offsetLeft;
      } else {
        return e.clientX - canvas.offsetLeft;
      }
    }

    function getY(e) {
      if (e.type === 'touchmove' || e.type === 'touchend') {
        return e.touches[0].clientY - canvas.offsetTop;
      } else {
        return e.clientY - canvas.offsetTop;
      }
    }

    canvas.addEventListener('mousedown', startDrawing);
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('touchstart', startDrawing);
    canvas.addEventListener('touchmove', draw);
    canvas.addEventListener('touchend', stopDrawing);
    document.getElementById('clearCanvas').addEventListener('click', clearCanvas);

    // Accelerometer Data
    const accelerometerData = [];

    function handleAccelerometerData(e) {
      const acceleration = e.accelerationIncludingGravity;
      const timestamp = new Date().toISOString();
      accelerometerData.push({
        timestamp: timestamp,
        accelerationX: acceleration.x,
        accelerationY: acceleration.y,
        accelerationZ: acceleration.z
      });
      document.getElementById('accelerometerTable').getElementsByTagName('tbody')[0].innerHTML += `
        <tr>
          <td>${timestamp}</td>
          <td>${acceleration.x}</td>
          <td>${acceleration.y}</td>
          <td>${acceleration.z}</td>
        </tr>
      `;
    }

    function exportData() {
      const name = document.getElementById('name').value;
      const voiceBlob = new Blob(chunks, { type: 'audio/mpeg' });
      const handwritingDataURL = canvas.toDataURL('image/png');
      const accelerometerCSV = accelerometerData.map(row => Object.values(row).join(',')).join('\n');

      // TODO: Implement sending data to server or cloud storage
      console.log('Name:', name);
      console.log('Voice Blob:', voiceBlob);
      console.log('Handwriting Data URL:', handwritingDataURL);
      console.log('Accelerometer CSV:', accelerometerCSV);
    }

    window.addEventListener('devicemotion', handleAccelerometerData);
    document.getElementById('submitData').addEventListener('click', exportData);
  </script>
</body>
</html>
